<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Image Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      margin: 0;
      overflow: hidden; /* Scroll d√©sactiv√© - zoom uniquement */
      font-family: 'Roboto', Arial, sans-serif;
      background-color: #ffffff; /* FOND BLANC */
      position: relative;
    }
    canvas {
      display: block;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1;
    }

    /* ===============================================
       ARRI√àRE-PLANS JONAS
       =============================================== */

    /* Fond de couleur pour Jonas normal (blanc) */
    #jonas-bg-color {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      min-height: 100vh;
      background-color: #ffffff;
      z-index: 0;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
    }

    #jonas-bg-color.visible {
      opacity: 1;
    }

    /* Typo Jonas (noire sur transparent) - Touche J - PREMIER PLAN */
    #jonas-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      min-height: 100vh;
      background-image: url('./Ressources/fond_jonas.png?v=2');
      background-size: cover;
      background-position: top center;
      background-repeat: no-repeat;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
      mix-blend-mode: multiply;
    }

    #jonas-background.visible {
      opacity: 1;
    }

    /* Fond de couleur pour Jonas n√©gatif (noir) */
    #jonas-bg-color-negatif {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      min-height: 100vh;
      background-color: #000000;
      z-index: 0;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
    }

    #jonas-bg-color-negatif.visible {
      opacity: 1;
    }

    /* Typo Jonas n√©gatif (blanche sur transparent) - Touche N - PREMIER PLAN */
    #jonas-background-negatif {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      min-height: 100vh;
      background-image: url('./Ressources/fond_jonas_negatif.png?v=2');
      background-size: cover;
      background-position: top center;
      background-repeat: no-repeat;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    #jonas-background-negatif.visible {
      opacity: 1;
    }

    /* FIN SECTION ARRI√àRE-PLANS JONAS */

    /* ===============================================
       INTERFACE DE PARAM√âTRAGE
       =============================================== */

    #settings-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.9);
      color: #ffffff;
      padding: 0;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      z-index: 1000;
      display: none;
      width: 290px;
      font-family: 'Roboto', Arial, sans-serif;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    }

    #settings-panel.visible {
      display: block;
    }

    .settings-content {
      padding: 20px;
      max-height: calc(100vh - 80px);
      overflow-y: auto;
    }

    .settings-content::-webkit-scrollbar {
      width: 6px;
    }

    .settings-content::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
    }

    .settings-content::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }

    .param-control {
      margin-bottom: 20px;
    }

    .param-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .param-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      font-weight: 500;
      color: #999;
    }

    .param-value-display {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .param-value {
      font-size: 11px;
      font-weight: 700;
      color: #fff;
      min-width: 35px;
      text-align: right;
    }

    .param-buttons {
      display: flex;
      gap: 2px;
    }

    .param-btn {
      width: 18px;
      height: 18px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    .param-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .param-slider-container {
      position: relative;
    }

    .param-control input[type="range"] {
      width: 100%;
      height: 2px;
      border-radius: 1px;
      background: rgba(255, 255, 255, 0.2);
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }

    .param-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
    }

    .param-control input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #fff;
      cursor: pointer;
      border: none;
    }

    .param-checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 15px;
    }

    .param-checkbox input[type="checkbox"] {
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .param-checkbox label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      font-weight: 500;
      color: #999;
      cursor: pointer;
    }

    .settings-divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.1);
      margin: 20px 0;
    }

    .settings-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 20px;
    }

    .settings-btn {
      width: 100%;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .settings-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .settings-btn.primary {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    /* Boutons de forme (rond/carr√©) */
    .shape-buttons {
      display: flex;
      gap: 8px;
      margin-top: 10px;
    }

    .shape-btn {
      flex: 1;
      height: 40px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 20px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .shape-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .shape-btn.active {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.5);
    }

    /* Boutons de mode de mouvement */
    .movement-mode-buttons {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 4px;
      margin-top: 10px;
    }

    .movement-mode-btn {
      height: 30px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 10px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .movement-mode-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .movement-mode-btn.active {
      background: rgba(255, 255, 255, 0.25);
      border-color: rgba(255, 255, 255, 0.5);
    }

    /* FIN INTERFACE DE PARAM√âTRAGE */

    /* ===============================================
       INTERFACE √âTATS DE LECTURE (Touche M)
       =============================================== */

    #ux-states-panel {
      position: fixed;
      top: 50%;
      left: 20px;
      transform: translateY(-50%);
      background-color: rgba(0, 0, 0, 0.95);
      color: #ffffff;
      padding: 0;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 8px;
      z-index: 2000;
      display: none;
      width: 400px;
      font-family: 'Roboto', Arial, sans-serif;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
    }

    #ux-states-panel.visible {
      display: block;
    }

    .ux-states-header {
      padding: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      text-align: center;
    }

    .ux-states-title {
      font-size: 16px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      margin: 0;
    }

    .ux-states-content {
      padding: 20px;
      max-height: 60vh;
      overflow-y: auto;
    }

    .ux-states-content::-webkit-scrollbar {
      width: 6px;
    }

    .ux-states-content::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
    }

    .ux-states-content::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
    }

    .ux-states-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 20px;
    }

    .ux-state-btn {
      flex: 1;
      min-width: 80px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }

    .ux-state-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .ux-state-btn.active {
      background: rgba(85, 255, 255, 0.2);
      border-color: rgba(85, 255, 255, 0.6);
      color: #55ffff;
    }

    .ux-add-state-btn {
      width: 100%;
      padding: 12px;
      background: rgba(255, 255, 255, 0.1);
      border: 2px dashed rgba(255, 255, 255, 0.3);
      color: #fff;
      font-size: 20px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 20px;
    }

    .ux-add-state-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.5);
    }

    .ux-apply-btn {
      width: 100%;
      padding: 15px;
      background: rgba(85, 255, 255, 0.15);
      border: 2px solid rgba(85, 255, 255, 0.4);
      color: #55ffff;
      font-size: 14px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 20px;
    }

    .ux-apply-btn:hover:not(:disabled) {
      background: rgba(85, 255, 255, 0.25);
      border-color: rgba(85, 255, 255, 0.6);
    }

    .ux-apply-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.1);
      color: #666;
    }

    .ux-curve-selector {
      margin-bottom: 20px;
    }

    .ux-curve-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      font-weight: 500;
      color: #999;
      margin-bottom: 8px;
    }

    .ux-curve-select {
      width: 100%;
      padding: 10px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 4px;
    }

    .ux-curve-select option {
      background: #000;
      color: #fff;
    }

    .ux-toggle-btn {
      width: 100%;
      padding: 15px;
      background: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: #fff;
      font-size: 14px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 4px;
    }

    .ux-toggle-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
    }

    .ux-toggle-btn.active {
      background: rgba(85, 255, 255, 0.25);
      border-color: rgba(85, 255, 255, 0.6);
      color: #55ffff;
    }

    /* FIN INTERFACE √âTATS DE LECTURE */

    /* ===============================================
       SECTION D√âSACTIV√âE - √âL√âMENTS UI SUPPRIM√âS
       ===============================================
       Cette section contient tous les √©l√©ments UI qui ont √©t√© d√©sactiv√©s :
       - Curseur personnalis√©
       - Bouton reset/replace
       - Fl√®ches de navigation
       - Titre "AURORA UNREALIS"
       - Page d'accueil/intro overlay
       - Boutons mode sc√®ne/cam√©ra
    */

    /*
    #custom-cursor {
      position: fixed;
      width: 16px;
      height: 16px;
      background-color: white;
      pointer-events: none;
      z-index: 99999;
      box-shadow:
        0 0 4px 1px rgba(85, 255, 255, 0.5),
        0 0 8px 2px rgba(85, 255, 255, 0.3),
        0 0 12px 3px rgba(106, 13, 173, 0.15);
      left: 0;
      top: 0;
      transform: translate(-50%, -50%);
      transition: opacity 0.5s ease-in-out;
      mix-blend-mode: screen;
    }

    #ui-overlay {
      position: absolute;
      bottom: 0px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: row;
      gap: 15px;
      padding: 12px 15px;
      border-radius: 10px;
      display: none;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }

    #ui-overlay button {
      background-color: transparent;
      color: #55ffff;
      border: none;
      outline: none;
      padding: 16px 35px;
      margin: 3px;
      font-size: 24px;
      cursor: pointer;
      border-radius: 50px;
      font-family: "comma-sans", sans-serif;
      font-weight: 700;
      font-style: normal;
      text-transform: uppercase;
      opacity: 1;
      transition: text-shadow 0.3s, transform 0.3s;
      text-shadow:
        0 0 8px rgba(85, 255, 255, 0.9),
        0 0 16px rgba(85, 255, 255, 0.6),
        0 0 24px rgba(106, 13, 173, 0.4);
    }

    .arrow {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background-color: transparent;
      color: #55ffff;
      border: none;
      cursor: pointer;
      font-size: 60px;
      font-weight: 400;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      opacity: 1;
      transition: text-shadow 0.3s, transform 0.3s, opacity 0.5s ease-in-out;
      display: none;
      padding: 20px;
      border-radius: 50%;
    }

    #page-title {
      position: absolute;
      top: 0px;
      left: 50%;
      transform: translateX(-50%);
      color: #55ffff;
      font-size: clamp(22px, 4vw, 38px);
      font-family: "new-astro", sans-serif;
      font-weight: 700;
      font-style: normal;
      z-index: 15;
      display: none;
      cursor: pointer;
      padding: 12px 25px;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      margin: 0 20px;
    }

    #intro-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 1);
      backdrop-filter: blur(0.5px);
      display: flex;
      align-items: flex-start;
      justify-content: center;
      flex-direction: column;
      color: #55ffff;
      font-size: clamp(30px, 10vw, 216px);
      font-family: "new-astro", sans-serif;
      font-weight: 700;
      font-style: normal;
      z-index: 20;
      padding: 30px clamp(15px, 4vw, 60px);
      box-sizing: border-box;
      overflow: visible;
      transition: background 1.5s ease-out, opacity 1.0s ease-out;
    }

    #view-mode-container {
      position: absolute;
      bottom: 50%;
      right: 12px;
      transform: translateY(50%);
      display: none;
      flex-direction: column;
      gap: 10px;
      z-index: 15;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }

    .view-mode-btn {
      width: 50px;
      height: 50px;
      background-color: transparent;
      border: 2px solid #55ffff;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      color: #55ffff;
      transition: transform 0.3s ease;
    }
    */
    /* FIN SECTION D√âSACTIV√âE */

    /* ===============================================
       SCROLL CONFIG PANEL (Touche C)
       =============================================== */
    #scroll-config-panel {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.95);
      border: 2px solid #55ffff;
      border-radius: 16px;
      padding: 20px 30px;
      color: #ffffff;
      font-family: 'Roboto', Arial, sans-serif;
      z-index: 1000;
      display: none;
      min-width: 700px;
      box-shadow: 0 0 30px rgba(85, 255, 255, 0.5);
    }

    #scroll-config-panel.visible {
      display: block;
    }

    .scroll-config-header {
      text-align: center;
      margin-bottom: 20px;
      font-size: 18px;
      font-weight: 700;
      color: #55ffff;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .scroll-config-content {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .scroll-config-section {
      background: rgba(255, 255, 255, 0.05);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid rgba(85, 255, 255, 0.2);
    }

    .scroll-config-section h3 {
      margin: 0 0 12px 0;
      font-size: 14px;
      color: #55ffff;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .scroll-param {
      margin-bottom: 12px;
    }

    .scroll-param label {
      display: block;
      font-size: 12px;
      margin-bottom: 5px;
      color: #aaaaaa;
    }

    .scroll-param input[type="range"] {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      outline: none;
      -webkit-appearance: none;
    }

    .scroll-param input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #55ffff;
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(85, 255, 255, 0.8);
    }

    .scroll-param input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      background: #55ffff;
      cursor: pointer;
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(85, 255, 255, 0.8);
    }

    .scroll-param .value-display {
      display: inline-block;
      margin-left: 8px;
      font-size: 12px;
      color: #55ffff;
      font-weight: 700;
      min-width: 50px;
    }

    .scroll-config-buttons {
      grid-column: 1 / -1;
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 15px;
    }

    .scroll-config-btn {
      padding: 10px 20px;
      background: rgba(85, 255, 255, 0.1);
      border: 1px solid #55ffff;
      border-radius: 8px;
      color: #55ffff;
      font-size: 13px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .scroll-config-btn:hover {
      background: rgba(85, 255, 255, 0.2);
      box-shadow: 0 0 15px rgba(85, 255, 255, 0.5);
      transform: translateY(-2px);
    }

    .scroll-config-btn.primary {
      background: #55ffff;
      color: #000000;
    }

    .scroll-config-btn.primary:hover {
      background: #77ffff;
      box-shadow: 0 0 20px rgba(85, 255, 255, 0.8);
    }

  </style>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
  <!-- ARRI√àRE-PLANS JONAS -->
  <!-- Fond blanc + typo noire (touche J) -->
  <div id="jonas-bg-color"></div>
  <div id="jonas-background"></div>

  <!-- Fond noir + typo blanche (touche N) -->
  <div id="jonas-bg-color-negatif"></div>
  <div id="jonas-background-negatif"></div>

  <!-- SCROLL CONFIG PANEL (Touche C) -->
  <div id="scroll-config-panel">
    <div class="scroll-config-header">‚öôÔ∏è Scroll Configuration (Press C to toggle)</div>
    <div class="scroll-config-content">

      <!-- Trackpad Settings -->
      <div class="scroll-config-section">
        <h3>üì± Trackpad</h3>

        <div class="scroll-param">
          <label>Sensitivity <span class="value-display" id="trackpad-sensitivity-val">0.000267</span></label>
          <input type="range" id="trackpad-sensitivity" min="0.0001" max="0.001" step="0.00001" value="0.000267">
        </div>

        <div class="scroll-param">
          <label>Detection Threshold (deltaY max) <span class="value-display" id="trackpad-threshold-val">70</span></label>
          <input type="range" id="trackpad-threshold" min="10" max="100" step="1" value="70">
        </div>

        <div class="scroll-param">
          <label>Frequency Threshold (ms) <span class="value-display" id="trackpad-frequency-val">39</span></label>
          <input type="range" id="trackpad-frequency" min="10" max="60" step="1" value="39">
        </div>
      </div>

      <!-- Mouse Wheel Settings (PRO: Virtual Accumulator System) -->
      <div class="scroll-config-section">
        <h3>üñ±Ô∏è Mouse Wheel (PRO Smoothing)</h3>
        <p style="font-size: 11px; opacity: 0.7; margin: 5px 0 10px;">Technique Lenis: accumulateur virtuel + lerp adaptatif</p>

        <div class="scroll-param">
          <label>Wheel Multiplier <span class="value-display" id="wheel-multiplier-val">0.93</span></label>
          <input type="range" id="wheel-multiplier" min="0.5" max="5" step="0.1" value="0.93">
          <p style="font-size: 10px; opacity: 0.6; margin: 2px 0 0;">Compensation pour synchroniser avec trackpad</p>
        </div>

        <div class="scroll-param">
          <label>Wheel Lerp <span class="value-display" id="wheel-lerp-val">0.22</span></label>
          <input type="range" id="wheel-lerp" min="0.05" max="0.5" step="0.01" value="0.22">
          <p style="font-size: 10px; opacity: 0.6; margin: 2px 0 0;">Distribution fluide sur plusieurs frames (0.15-0.25 optimal)</p>
        </div>
      </div>

      <!-- Global Settings -->
      <div class="scroll-config-section">
        <h3>üåç Global</h3>

        <div class="scroll-param">
          <label>Zoom Lerp Speed <span class="value-display" id="zoom-lerp-val">0.22</span></label>
          <input type="range" id="zoom-lerp" min="0.05" max="0.3" step="0.01" value="0.22">
        </div>

        <div class="scroll-param">
          <label>Disparity Lerp Speed <span class="value-display" id="disparity-lerp-val">0.23</span></label>
          <input type="range" id="disparity-lerp" min="0.05" max="0.5" step="0.01" value="0.23">
        </div>
      </div>

      <!-- Info Section -->
      <div class="scroll-config-section">
        <h3>‚ÑπÔ∏è Info</h3>
        <div style="font-size: 11px; color: #aaa; line-height: 1.6;">
          <p><strong>Current Mode:</strong> <span id="scroll-mode-indicator">Detecting...</span></p>
          <p><strong>Last DeltaY:</strong> <span id="scroll-delta-indicator">0</span></p>
          <p><strong>Last Frequency:</strong> <span id="scroll-freq-indicator">0ms</span></p>
          <p style="margin-top: 10px; color: #55ffff;">Scroll to see live detection!</p>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="scroll-config-buttons">
        <button class="scroll-config-btn" id="scroll-reset-btn">Reset to Default</button>
        <button class="scroll-config-btn primary" id="scroll-copy-btn">üìã Copy Config to Clipboard</button>
      </div>
    </div>
  </div>

  <!-- INTERFACE DE PARAM√âTRAGE -->
  <div id="settings-panel">
    <div class="settings-content">

      <!-- Point Size -->
      <div class="param-control">
        <div class="param-header">
          <span class="param-label">Point Size</span>
          <div class="param-value-display">
            <span class="param-value" id="size-value">0.02</span>
            <div class="param-buttons">
              <button class="param-btn" data-param="size" data-action="decrease">‚ñº</button>
              <button class="param-btn" data-param="size" data-action="increase">‚ñ≤</button>
            </div>
          </div>
        </div>
        <div class="param-slider-container">
          <input type="range" id="size-slider" min="0" max="0.04" step="0.002" value="0.02">
        </div>
      </div>

      <!-- Particle Shape -->
      <div class="param-control">
        <div class="param-header">
          <span class="param-label">Particle Shape</span>
        </div>
        <div class="shape-buttons">
          <button class="shape-btn active" data-shape="circle">‚óè</button>
          <button class="shape-btn" data-shape="square">‚ñ†</button>
        </div>
      </div>

      <!-- Particle Density -->
      <div class="param-control">
        <div class="param-header">
          <span class="param-label">Particle Density</span>
          <div class="param-value-display">
            <span class="param-value" id="density-value">0.4</span>
            <div class="param-buttons">
              <button class="param-btn" data-param="density" data-action="decrease">‚ñº</button>
              <button class="param-btn" data-param="density" data-action="increase">‚ñ≤</button>
            </div>
          </div>
        </div>
        <div class="param-slider-container">
          <input type="range" id="density-slider" min="0" max="2" step="0.05" value="0.4">
        </div>
      </div>

      <!-- Depth Spread -->
      <div class="param-control">
        <div class="param-header">
          <span class="param-label">Depth Spread</span>
          <div class="param-value-display">
            <span class="param-value" id="disparity-value">0.0</span>
            <div class="param-buttons">
              <button class="param-btn" data-param="disparity" data-action="decrease">‚ñº</button>
              <button class="param-btn" data-param="disparity" data-action="increase">‚ñ≤</button>
            </div>
          </div>
        </div>
        <div class="param-slider-container">
          <input type="range" id="disparity-slider" min="0" max="16" step="0.5" value="0">
        </div>
      </div>

      <!-- Breath Speed -->
      <div class="param-control">
        <div class="param-header">
          <span class="param-label">Breath Speed</span>
          <div class="param-value-display">
            <span class="param-value" id="movement-value">0.000</span>
            <div class="param-buttons">
              <button class="param-btn" data-param="movement" data-action="decrease">‚ñº</button>
              <button class="param-btn" data-param="movement" data-action="increase">‚ñ≤</button>
            </div>
          </div>
        </div>
        <div class="param-slider-container">
          <input type="range" id="movement-slider" min="0" max="0.5" step="0.01" value="0">
        </div>
      </div>

      <!-- Movement Mode -->
      <div class="param-control">
        <div class="param-header">
          <span class="param-label">Movement Mode</span>
        </div>
        <div class="movement-mode-buttons">
          <button class="movement-mode-btn active" data-mode="1">Z</button>
          <button class="movement-mode-btn" data-mode="2">XY</button>
          <button class="movement-mode-btn" data-mode="3">XYZ</button>
          <button class="movement-mode-btn" data-mode="4">WAVE</button>
          <button class="movement-mode-btn" data-mode="5">SPIRAL</button>
        </div>
      </div>

      <!-- Brightness (Saturation) -->
      <div class="param-control">
        <div class="param-header">
          <span class="param-label">Brightness</span>
          <div class="param-value-display">
            <span class="param-value" id="saturation-value">1.0</span>
            <div class="param-buttons">
              <button class="param-btn" data-param="saturation" data-action="decrease">‚ñº</button>
              <button class="param-btn" data-param="saturation" data-action="increase">‚ñ≤</button>
            </div>
          </div>
        </div>
        <div class="param-slider-container">
          <input type="range" id="saturation-slider" min="0" max="4" step="0.1" value="1">
        </div>
      </div>

      <!-- Hide Black -->
      <div class="param-control">
        <div class="param-header">
          <span class="param-label">Hide Black</span>
          <div class="param-value-display">
            <span class="param-value" id="hideBlack-value">0.0</span>
            <div class="param-buttons">
              <button class="param-btn" data-param="hideBlack" data-action="decrease">‚ñº</button>
              <button class="param-btn" data-param="hideBlack" data-action="increase">‚ñ≤</button>
            </div>
          </div>
        </div>
        <div class="param-slider-container">
          <input type="range" id="hideBlack-slider" min="0" max="1" step="0.05" value="0">
        </div>
      </div>

      <!-- Grid Randomness -->
      <div class="param-control">
        <div class="param-header">
          <span class="param-label">Grid Randomness</span>
          <div class="param-value-display">
            <span class="param-value" id="randomness-value">0.00</span>
            <div class="param-buttons">
              <button class="param-btn" data-param="randomness" data-action="decrease">‚ñº</button>
              <button class="param-btn" data-param="randomness" data-action="increase">‚ñ≤</button>
            </div>
          </div>
        </div>
        <div class="param-slider-container">
          <input type="range" id="randomness-slider" min="0" max="2" step="0.05" value="0">
        </div>
      </div>

      <div class="settings-divider"></div>

      <!-- Buttons -->
      <div class="settings-buttons">
        <button class="settings-btn primary" id="apply-btn">Apply</button>
        <button class="settings-btn" id="reset-defaults-btn">Reset to Defaults</button>
        <button class="settings-btn" id="reset-camera-btn">Reset Camera</button>
      </div>

    </div>
  </div>

  <!-- ===============================================
       SECTION D√âSACTIV√âE - √âL√âMENTS HTML SUPPRIM√âS
       =============================================== -->
  <!--
  <div id="custom-cursor"></div>
  <div id="page-title" onclick="location.reload();">AURORA UNREALIS</div>
  <div id="intro-overlay">
    <div id="title-container">
      <div>AURORA</div>
      <div>UNREALIS</div>
    </div>
    <button id="startButton">&gt;&gt;</button>
  </div>
  <div id="ui-overlay">
    <button id="resetCamera">replace</button>
  </div>
  <button id="arrow-left" class="arrow">&lt;</button>
  <button id="arrow-right" class="arrow">&gt;</button>
  <div id="view-mode-container">
    <button id="mode-scene" class="view-mode-btn active">‚äõ</button>
    <button id="mode-camera" class="view-mode-btn">‚óâ</button>
  </div>
  -->
  <!-- FIN SECTION D√âSACTIV√âE -->

  <!-- INTERFACE √âTATS DE LECTURE (Touche M) -->
  <div id="ux-states-panel">
    <div class="ux-states-header">
      <h2 class="ux-states-title">√âtats de Lecture</h2>
    </div>
    <div class="ux-states-content">
      <!-- Liste des √©tats -->
      <div id="ux-states-list" class="ux-states-list">
        <!-- Les boutons d'√©tats seront ajout√©s dynamiquement -->
      </div>

      <!-- Bouton ajouter √©tat -->
      <button class="ux-add-state-btn" id="ux-add-state">+</button>

      <!-- Bouton appliquer les param√®tres -->
      <button class="ux-apply-btn" id="ux-apply-state" disabled>Apply</button>

      <!-- S√©lecteur de courbe -->
      <div class="ux-curve-selector">
        <div class="ux-curve-label">Type de Courbe</div>
        <select class="ux-curve-select" id="ux-curve-type">
          <option value="linear">Lin√©aire</option>
          <option value="easeIn" selected>Ease In (Acc√©l√©ration)</option>
          <option value="easeOut">Ease Out (D√©c√©l√©ration)</option>
          <option value="easeInOut">Ease In-Out (S-Curve)</option>
        </select>
      </div>

      <!-- Bouton activer/d√©sactiver -->
      <button class="ux-toggle-btn" id="ux-toggle">Actif</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ===============================================
    // VERSION √âPUR√âE - UNIQUEMENT PARTICULES
    // ===============================================

    // Initialisation de la sc√®ne, cam√©ra et rendu
    const scene = new THREE.Scene();
    // Pas de fond de sc√®ne - transparent pour voir les arri√®re-plans Jonas

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // Cr√©er le renderer avec gestion d'erreur
    let renderer;
    try {
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
        preserveDrawingBuffer: false,
        powerPreference: "high-performance"
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
    } catch (error) {
      console.error('WebGL error:', error);
      document.body.innerHTML = '<div style="color: white; padding: 20px; font-family: Arial;">WebGL n\'est pas disponible. Essayez de rafra√Æchir la page (Ctrl+F5) ou red√©marrez votre navigateur.</div>';
      throw error;
    }

    // GROUPE pour contenir les particules
    const sceneGroup = new THREE.Group();
    scene.add(sceneGroup);

    let particles;
    let currentImageIndex = 1; // Commence √† 1 (IMG_001)
    const maxImageIndex = 4; // 4 images : IMG_001, IMG_002, IMG_003, IMG_004
    let referenceHeight = null;

    // Variables pour le zoom progressif avec scroll
    let zoomLevel = 0;
    let targetZoomLevel = 0;
    const minZoom = -25; // Position loin
    const maxZoom = -2;  // Position proche

    // Syst√®me de cycle de scroll bidirectionnel avec inversion automatique
    const MAX_ZOOM_LEVEL = 0.85; // Zoom max r√©duit (avant √©tat 7 complet)
    let scrollPhase = 'zoomIn';  // 'zoomIn' ou 'zoomOut' (cycle infini bidirectionnel)

    const textureLoader = new THREE.TextureLoader();

    // Canvas r√©utilisable pour optimisation (Phase 1 - Opt #4)
    const offscreenCanvas = document.createElement('canvas');
    const offscreenContext = offscreenCanvas.getContext('2d');

    // Param√®tres modifiables pour les particules
    let particleParams = {
      density: 0.4,        // Densit√© bloqu√©e √† 0.4
      disparity: 0.0,      // Disparit√© en profondeur Z
      size: 0.02,          // Taille des particules
      movement: 0.0,       // Pas de mouvement
      saturation: 1.0,     // Saturation chromatique
      hideBlack: 0.0,      // Seuil pour masquer les pixels noirs (0 = aucun, 1 = tous les noirs)
      randomness: 0.0,     // Al√©atoire du positionnement (0 = grille parfaite, 1 = d√©sorganis√©)
      shape: 'circle',     // Forme des particules (circle ou square)
      movementMode: 1      // Mode de mouvement (1: Z, 2: XY, 3: XYZ, 4: WAVE, 5: SPIRAL)
    };

    // Syst√®me de parcours UX avec √©tats multiples
    let uxJourneyMode = true; // Activ√© par d√©faut
    let currentStateIndex = -1; // √âtat actuellement s√©lectionn√© (-1 = aucun)
    let selectedCurveType = 'linear'; // Lin√©aire par d√©faut

    // √âtats par d√©faut (toujours utilis√©s, pas de localStorage)
    let uxStates = [
      {
        "name": "√âtat 1",
        "size": 0.04,
        "density": 0.6000000000000001,
        "disparity": 0,
        "movement": 0,
        "randomness": 0.4,
        "saturation": 1,
        "hideBlack": 0,
        "shape": "circle",
        "movementMode": 2
      },
      {
        "name": "√âtat 2",
        "size": 0.039999999869791684,
        "density": 0.6,
        "disparity": 0.4799997184245186,
        "movement": 0,
        "randomness": 0.4,
        "saturation": 1,
        "hideBlack": 0,
        "shape": "circle",
        "movementMode": 2
      },
      {
        "name": "√âtat 3",
        "size": 0.03999999960937498,
        "density": 0.6,
        "disparity": 2.5,
        "movement": 0,
        "randomness": 0.4,
        "saturation": 1,
        "hideBlack": 0,
        "shape": "circle",
        "movementMode": 2
      },
      {
        "name": "√âtat 4",
        "size": 0.04,
        "density": 0.6,
        "disparity": 2.5,
        "movement": 0,
        "randomness": 0.4,
        "saturation": 1,
        "hideBlack": 0,
        "shape": "circle",
        "movementMode": 2
      },
      {
        "name": "√âtat 5",
        "size": 0.04,
        "density": 0.6,
        "disparity": 2.5,
        "movement": 0.07,
        "randomness": 0.4,
        "saturation": 1,
        "hideBlack": 0,
        "shape": "circle",
        "movementMode": 2
      },
      {
        "name": "√âtat 6",
        "size": 0.04,
        "density": 0.6,
        "disparity": 2.5,
        "movement": 0.2,
        "randomness": 0.4,
        "saturation": 1,
        "hideBlack": 0,
        "shape": "circle",
        "movementMode": 2
      },
      {
        "name": "√âtat 7",
        "size": 0.04,
        "density": 0.6,
        "disparity": 2.7733333642577858,
        "movement": 0.5,
        "randomness": 0.4,
        "saturation": 1,
        "hideBlack": 0,
        "shape": "circle",
        "movementMode": 2
      }
    ];

    // Fonctions d'easing pour diff√©rentes courbes
    function linear(t) {
      return t;
    }

    function easeIn(t) {
      return t * t;
    }

    function easeOut(t) {
      return 1 - Math.pow(1 - t, 2);
    }

    function easeInOut(t) {
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    // Fonction pour appliquer la courbe s√©lectionn√©e
    function applyCurve(t) {
      switch(selectedCurveType) {
        case 'linear': return linear(t);
        case 'easeIn': return easeIn(t);
        case 'easeOut': return easeOut(t);
        case 'easeInOut': return easeInOut(t);
        default: return t;
      }
    }

    // Fonction de hash d√©terministe pour randomness bas√©e sur coordonn√©es
    function seededRandom(x, y, seed = 12345) {
      const combined = (x * 73856093) ^ (y * 19349663) ^ seed;
      const normalized = Math.abs(Math.sin(combined)) * 10000;
      return (normalized % 1000) / 1000; // Retourne entre 0 et 1
    }

    // Saturation des couleurs
    function saturateColor(r, g, b, intensity) {
      const avg = (r + g + b) / 3;
      r = avg + (r - avg) * intensity;
      g = avg + (g - avg) * intensity;
      b = avg + (b - avg) * intensity;
      return { r: Math.min(r, 1), g: Math.min(g, 1), b: Math.min(b, 1) };
    }

    // Version des images (incr√©menter ce nombre quand vous changez les images)
    const IMAGE_VERSION = 2;

    // Cache pour les images pr√©-charg√©es
    const imageCache = new Map(); // imageIndex -> ImageData
    const textureCache = {
      circle: null,
      square: null
    };
    let imagesPreloaded = false;

    // Pr√©-charger toutes les images au d√©marrage
    function preloadAllImages() {
      const targetWidth = 1720;
      const targetHeight = 880;
      const loadPromises = [];

      for (let idx = 1; idx <= maxImageIndex; idx++) {
        const imagePath = `./Ressources/IMG_${String(idx).padStart(3, '0')}.jpg?v=${IMAGE_VERSION}`;

        const promise = new Promise((resolve, reject) => {
          textureLoader.load(imagePath, function (texture) {
            // Canvas temporaire pour cette image
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = targetWidth;
            tempCanvas.height = targetHeight;
            const tempContext = tempCanvas.getContext('2d');

            // Calculer le ratio pour rogner (crop) au lieu d'√©tirer
            const srcWidth = texture.image.width;
            const srcHeight = texture.image.height;
            const targetRatio = targetWidth / targetHeight;
            const srcRatio = srcWidth / srcHeight;

            let cropX = 0, cropY = 0, cropWidth = srcWidth, cropHeight = srcHeight;

            if (srcRatio > targetRatio) {
              cropWidth = srcHeight * targetRatio;
              cropX = (srcWidth - cropWidth) / 2;
            } else {
              cropHeight = srcWidth / targetRatio;
              cropY = (srcHeight - cropHeight) / 2;
            }

            // Dessiner et extraire ImageData
            tempContext.drawImage(
              texture.image,
              cropX, cropY, cropWidth, cropHeight,
              0, 0, targetWidth, targetHeight
            );
            const imgData = tempContext.getImageData(0, 0, targetWidth, targetHeight);

            // Stocker dans le cache
            imageCache.set(idx, imgData);
            resolve();
          }, undefined, reject);
        });

        loadPromises.push(promise);
      }

      return Promise.all(loadPromises).then(() => {
        imagesPreloaded = true;
        console.log(`‚úÖ ${maxImageIndex} images pr√©-charg√©es en cache`);
      });
    }

    // Cr√©er et cacher les textures de particules
    function createParticleTexture(shape) {
      if (textureCache[shape]) {
        return textureCache[shape];
      }

      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');

      if (shape === 'square') {
        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
        ctx.fillRect(0, 0, 64, 64);
      } else {
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
      }

      const texture = new THREE.CanvasTexture(canvas);
      texture.needsUpdate = true;
      textureCache[shape] = texture;
      return texture;
    }

    // Fonction de chargement d'image optimis√©e avec cache
    function loadImage(imageIndex) {
      const targetWidth = 1720;
      const targetHeight = 880;

      // Fonction interne pour construire la g√©om√©trie √† partir d'ImageData
      function buildGeometry(imgData) {

        const scaleFactor = 50;
        const particleGeometry = new THREE.BufferGeometry();

        // Utiliser la texture cach√©e au lieu de la recr√©er
        const particleTexture = createParticleTexture(particleParams.shape);

        const particleMaterial = new THREE.PointsMaterial({
          size: particleParams.size,
          vertexColors: true,
          transparent: true,
          opacity: 1,
          map: particleTexture,
          sizeAttenuation: true,
          depthWrite: false,
          blending: THREE.NormalBlending
        });

        const particleVertices = [];
        const particleColors = [];
        const normalizedDepths = []; // Profondeurs normalis√©es pour disparity dynamique

        // Appliquer la densit√© pour √©chantillonner les pixels
        const step = Math.max(1, Math.floor(1 / particleParams.density));

        for (let y = 0; y < targetHeight; y += step) {
          for (let x = 0; x < targetWidth; x += step) {
            const i = (y * targetWidth + x) * 4;
            let r = imgData.data[i] / 255;
            let g = imgData.data[i + 1] / 255;
            let b = imgData.data[i + 2] / 255;
            const a = imgData.data[i + 3] / 255;

            if (a > 0.5) {
              const saturated = saturateColor(r, g, b, particleParams.saturation);
              r = saturated.r;
              g = saturated.g;
              b = saturated.b;

              // Calculer la luminosit√© du pixel (0 = noir, 1 = blanc)
              const brightness = (r + g + b) / 3;

              // Filtrer les pixels noirs selon le seuil hideBlack
              // Si hideBlack = 0.3, on cache tous les pixels avec brightness < 0.3
              if (brightness >= particleParams.hideBlack) {
                // Position de base sur la grille
                let posX = (x - targetWidth / 2) / scaleFactor;
                let posY = (y - targetHeight / 2) / scaleFactor;
                // Stocker depth normalis√©e - disparity appliqu√© dynamiquement
                const normalizedDepth = seededRandom(x, y, 3) - 0.5;

                // Ajouter un offset al√©atoire bas√© sur le param√®tre randomness
                // Utilise randomness d√©terministe pour √©viter les saccades lors des reloads
                if (particleParams.randomness > 0) {
                  const randomOffsetX = (seededRandom(x, y, 1) - 0.5) * particleParams.randomness * (step / scaleFactor);
                  const randomOffsetY = (seededRandom(x, y, 2) - 0.5) * particleParams.randomness * (step / scaleFactor);
                  posX += randomOffsetX;
                  posY += randomOffsetY;
                }

                particleVertices.push(posX, posY, 0); // Z=0 au d√©part
                particleColors.push(r, g, b);
                normalizedDepths.push(normalizedDepth);
              }
            }
          }
        }

        particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
        particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(particleColors, 3));
        particleGeometry.setAttribute('normalizedDepth', new THREE.Float32BufferAttribute(normalizedDepths, 1));

        // Stocker les positions initiales pour le mouvement oscillant
        particleGeometry.setAttribute('initialPosition', new THREE.Float32BufferAttribute(particleVertices.slice(), 3));

        // Nettoyer les anciennes particules pour √©viter les fuites m√©moire
        if (particles) {
          sceneGroup.remove(particles);
          if (particles.geometry) particles.geometry.dispose();
          if (particles.material) particles.material.dispose();
        }

        particles = new THREE.Points(particleGeometry, particleMaterial);
        particles.rotation.x = Math.PI;
        // Initialiser le temps pour l'animation
        particles.userData.time = 0;
        sceneGroup.add(particles);

        // Forcer le render de la nouvelle image (Opt #5)
        hasInitialRender = false;
      }

      // Chemin optimis√©: utiliser cache si disponible
      if (imageCache.has(imageIndex)) {
        const cachedImgData = imageCache.get(imageIndex);
        buildGeometry(cachedImgData);
        return;
      }

      // Fallback: charger l'image si pas en cache
      const imagePath = `./Ressources/IMG_${String(imageIndex).padStart(3, '0')}.jpg?v=${IMAGE_VERSION}`;
      textureLoader.load(imagePath, function (texture) {
        offscreenCanvas.width = targetWidth;
        offscreenCanvas.height = targetHeight;

        const srcWidth = texture.image.width;
        const srcHeight = texture.image.height;
        const targetRatio = targetWidth / targetHeight;
        const srcRatio = srcWidth / srcHeight;

        let cropX = 0, cropY = 0, cropWidth = srcWidth, cropHeight = srcHeight;

        if (srcRatio > targetRatio) {
          cropWidth = srcHeight * targetRatio;
          cropX = (srcWidth - cropWidth) / 2;
        } else {
          cropHeight = srcWidth / targetRatio;
          cropY = (srcHeight - cropHeight) / 2;
        }

        offscreenContext.drawImage(
          texture.image,
          cropX, cropY, cropWidth, cropHeight,
          0, 0, targetWidth, targetHeight
        );
        const imgData = offscreenContext.getImageData(0, 0, targetWidth, targetHeight);

        // Stocker en cache pour future utilisation
        imageCache.set(imageIndex, imgData);
        buildGeometry(imgData);
      }, undefined, function (err) {
        console.error(`Erreur chargement image ${imageIndex}:`, err);
      });
    }

    /* ===============================================
       SECTION D√âSACTIV√âE - ENVIRONNEMENT IMMERSIF
       ===============================================
       Cette section contient tout le code de l'environnement immersif :
       - √âtoiles (3 couches)
       - √âtoiles filantes
       - Lune
       - Neige
       - Lumi√®res
    */

    /*
    const sphereRadius = 400;

    function getRealisticStarColor() {
      const rand = Math.random();
      if (rand < 0.5) return new THREE.Color(1, 1, 1);
      else if (rand < 0.7) return new THREE.Color(0.7, 0.85, 1);
      else if (rand < 0.85) return new THREE.Color(1, 0.95, 0.7);
      else return new THREE.Color(1, 0.7, 0.5);
    }

    function getUniformSpherePoint(radius) {
      const theta = Math.random() * Math.PI * 2;
      const u = Math.random() * 2 - 1;
      const phi = Math.acos(u);
      const x = radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi) * Math.sin(theta);
      const z = radius * Math.cos(phi);
      return { x, y, z };
    }

    // Grandes √©toiles
    const bigStarsGeometry = new THREE.BufferGeometry();
    const bigStarsVertices = [];
    const bigStarsColors = [];
    for (let i = 0; i < 150; i++) {
      const pos = getUniformSpherePoint(sphereRadius);
      bigStarsVertices.push(pos.x, pos.y, pos.z);
      const color = getRealisticStarColor();
      bigStarsColors.push(color.r, color.g, color.b);
    }
    bigStarsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(bigStarsVertices, 3));
    bigStarsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(bigStarsColors, 3));
    const bigStarsMaterial = new THREE.PointsMaterial({
      size: 0.07,
      vertexColors: true,
      transparent: true,
      opacity: 1.0,
    });
    const bigStars = new THREE.Points(bigStarsGeometry, bigStarsMaterial);
    sceneGroup.add(bigStars);

    // √âtoiles moyennes et petites (code similaire omis pour bri√®vet√©)

    // Lune
    const moonGeometry = new THREE.SphereGeometry(5, 32, 32);
    const moonMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xaaaaaa });
    const moon = new THREE.Mesh(moonGeometry, moonMaterial);
    moon.position.set(50, 100, -200);
    sceneGroup.add(moon);

    // Lumi√®res
    const moonLight = new THREE.PointLight(0xffffff, 1, 500);
    moonLight.position.set(50, 100, -200);
    sceneGroup.add(moonLight);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    // Neige
    const snowGeometry = new THREE.BufferGeometry();
    const snowMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.02,
      transparent: true,
      opacity: 0.8,
    });
    const snowVertices = [];
    for (let i = 0; i < 2000; i++) {
      const x = (Math.random() - 0.5) * 200;
      const y = Math.random() * 200;
      const z = (Math.random() - 0.5) * 200;
      snowVertices.push(x, y, z);
    }
    snowGeometry.setAttribute('position', new THREE.Float32BufferAttribute(snowVertices, 3));
    const snow = new THREE.Points(snowGeometry, snowMaterial);
    sceneGroup.add(snow);
    */

    /* FIN SECTION D√âSACTIV√âE - ENVIRONNEMENT */

    // Lumi√®re ambiante simple pour fond blanc
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambientLight);

    // Pr√©-charger toutes les images en arri√®re-plan, puis charger la premi√®re
    preloadAllImages().then(() => {
      loadImage(currentImageIndex);
    }).catch(err => {
      console.error('Erreur pr√©-chargement:', err);
      // Fallback: charger quand m√™me la premi√®re image
      loadImage(currentImageIndex);
    });

    // Position de la cam√©ra (mobile) et sceneGroup (fixe)
    camera.position.set(0, 0, 25); // Cam√©ra commence loin en arri√®re
    sceneGroup.position.set(0, 0, 0); // Particules fixes √† l'origine

    // Variables pour optimisations
    let hasInitialRender = false; // Pour forcer un premier render
    let lastAppliedDisparity = null; // Tracker disparity pour √©viter mises √† jour inutiles
    let currentAppliedDisparity = 0; // Disparity actuellement appliqu√©e (avec lerp)
    let needsPositionUpdate = false; // Batch GPU updates pour √©viter appels multiples
    let wheelScrollAccumulator = 0; // PRO: Accumulateur virtuel pour molette (technique Lenis/smooth-scroll)
    let lastScrollTime = 0; // Timestamp pour d√©tection trackpad vs molette

    // Variables pour d√©tection de reload des param√®tres
    let lastReloadParams = {
      density: 0.6,
      disparity: 0,
      saturation: 1,
      hideBlack: 0,
      randomness: 0.4,
      shape: 'circle'
    };
    let reloadScheduled = false;

    // Optimisation PRO: Function dispatch table pour √©liminer les branches
    // Au lieu de if/else if dans le loop chaud, on appelle directement la bonne fonction
    const movementFunctions = {
      // Mode 1: Mouvement sur Z uniquement
      1: (positions, initialPositions, i, time, movementDouble) => {
        const offset = i * 0.1;
        const oscillation = Math.sin(time + offset) * movementDouble;
        positions[i] = initialPositions[i];
        positions[i + 1] = initialPositions[i + 1];
        positions[i + 2] = initialPositions[i + 2] + oscillation;
      },

      // Mode 2: Mouvement sur X et Y
      2: (positions, initialPositions, i, time, movementDouble) => {
        const offset = i * 0.1;
        const offset13 = offset * 1.3;
        const timeOffset = time + offset;
        const oscillationX = Math.sin(timeOffset) * movementDouble;
        const oscillationY = Math.cos(time + offset13) * movementDouble;
        positions[i] = initialPositions[i] + oscillationX;
        positions[i + 1] = initialPositions[i + 1] + oscillationY;
        positions[i + 2] = initialPositions[i + 2];
      },

      // Mode 3: Mouvement sur tous les axes (XYZ)
      3: (positions, initialPositions, i, time, movementDouble) => {
        const offset = i * 0.1;
        const offset08 = offset * 0.8;
        const offset13 = offset * 1.3;
        const timeOffset = time + offset;
        const time07 = time * 0.7;
        const oscillationX = Math.sin(timeOffset) * movementDouble;
        const oscillationY = Math.cos(time + offset13) * movementDouble;
        const oscillationZ = Math.sin(time07 + offset08) * movementDouble;
        positions[i] = initialPositions[i] + oscillationX;
        positions[i + 1] = initialPositions[i + 1] + oscillationY;
        positions[i + 2] = initialPositions[i + 2] + oscillationZ;
      },

      // Mode 4: Mouvement en vague (WAVE)
      4: (positions, initialPositions, i, time, movementDouble) => {
        const initX = initialPositions[i];
        const initY = initialPositions[i + 1];
        const time15 = time * 1.5;
        const waveX = Math.sin(time + initX * 0.5) * movementDouble;
        const waveY = Math.cos(time + initY * 0.5) * movementDouble;
        const waveZ = Math.sin(time15 + initX * 0.3 + initY * 0.3) * movementDouble * 0.7;
        positions[i] = initX + waveX * 0.5;
        positions[i + 1] = initY + waveY * 0.5;
        positions[i + 2] = initialPositions[i + 2] + waveZ;
      },

      // Mode 5: Mouvement en spirale (SPIRAL)
      5: (positions, initialPositions, i, time, movementDouble) => {
        const offset = i * 0.1;
        const timeOffset = time + offset;
        const time2 = time * 2;
        const angle = timeOffset;
        const radius = movementDouble;
        const spiralX = Math.cos(angle) * radius * 0.6;
        const spiralY = Math.sin(angle) * radius * 0.6;
        const spiralZ = Math.sin(time2 + offset) * movementDouble * 0.8;
        positions[i] = initialPositions[i] + spiralX;
        positions[i + 1] = initialPositions[i + 1] + spiralY;
        positions[i + 2] = initialPositions[i + 2] + spiralZ;
      }
    };

    // Animation
    function animate() {
      requestAnimationFrame(animate);

      let needsRender = false; // (Opt #5 - Early exit)

      // Forcer le render initial quand les particules sont charg√©es
      if (particles && !hasInitialRender) {
        needsRender = true;
        hasInitialRender = true;
      }

      // PRO WHEEL SMOOTHING: Accumulateur virtuel avec lerp adaptatif (technique Lenis)
      // Convertit les clics discrets de molette en mouvement fluide continu
      if (Math.abs(wheelScrollAccumulator) > 0.0001) {
        const wheelContribution = wheelScrollAccumulator * scrollConfig.wheel.lerp;

        // CYCLE DE SCROLL: Inverser selon la phase
        if (scrollPhase === 'zoomIn') {
          targetZoomLevel += wheelContribution;
        } else if (scrollPhase === 'zoomOut') {
          targetZoomLevel -= wheelContribution; // INVERSION pour dezoom
        }

        targetZoomLevel = Math.max(0, Math.min(MAX_ZOOM_LEVEL, targetZoomLevel));
        // D√©croissance de l'accumulateur (inverse du lerp)
        wheelScrollAccumulator *= (1 - scrollConfig.wheel.lerp);
      }

      // D√âTECTION DES POINTS DE BASCULE: Cycle bidirectionnel infini
      if (scrollPhase === 'zoomIn' && targetZoomLevel >= MAX_ZOOM_LEVEL - 0.001) {
        // Atteint le zoom max ‚Üí passer en phase dezoom
        scrollPhase = 'zoomOut';
        console.log('üîÑ Phase transition: zoomIn ‚Üí zoomOut (max atteint)');
      } else if (scrollPhase === 'zoomOut' && targetZoomLevel <= 0.001) {
        // Retour √† l'√©tat 1 ‚Üí repasser en phase zoom (cycle bidirectionnel)
        scrollPhase = 'zoomIn';
        console.log('üîÑ Phase transition: zoomOut ‚Üí zoomIn (√©tat 1 atteint)');
      }

      // Zoom fluide progressif (interpolation vers la cible - configurable)
      if (Math.abs(targetZoomLevel - zoomLevel) > 0.001) {
        // Lerp fluide vers la position cible
        zoomLevel += (targetZoomLevel - zoomLevel) * scrollConfig.global.zoomLerp;
        // D√©placer la cam√©ra (au lieu du sceneGroup) : de z=25 (loin) √† z=0 (proche)
        camera.position.z = -minZoom - (-minZoom - maxZoom) * zoomLevel;

        needsRender = true;
      }

      // FIX MOLETTE: Calculer les param√®tres dans animate() avec zoomLevel LISS√â
      // Au lieu de les calculer dans wheel event avec targetZoomLevel (qui saute)
      if (uxJourneyMode && uxStates.length >= 2) {
        // FIX: Forcer retour exact √† l'√âtat 1 quand zoomLevel proche de 0
        if (zoomLevel < 0.001) {
          const state1 = uxStates[0];
          particleParams.size = state1.size;
          particleParams.density = state1.density;
          particleParams.disparity = state1.disparity;
          particleParams.movement = state1.movement;
          particleParams.randomness = state1.randomness;
          particleParams.saturation = state1.saturation;
          particleParams.hideBlack = state1.hideBlack;
          particleParams.shape = state1.shape;
          particleParams.movementMode = state1.movementMode;

          // CRITICAL FIX: Forcer reload IMM√âDIAT avec valeurs EXACTES de l'√âtat 1
          // Pour √©liminer tout "bruit" r√©siduel de l'interpolation
          const needsState1Reload =
            Math.abs(particleParams.density - lastReloadParams.density) > 0.001 ||
            Math.abs(particleParams.randomness - lastReloadParams.randomness) > 0.001 ||
            Math.abs(particleParams.saturation - lastReloadParams.saturation) > 0.001 ||
            Math.abs(particleParams.hideBlack - lastReloadParams.hideBlack) > 0.001 ||
            particleParams.shape !== lastReloadParams.shape;

          if (needsState1Reload && !reloadScheduled) {
            reloadScheduled = true;
            requestAnimationFrame(() => {
              loadImage(currentImageIndex);
              lastReloadParams = {
                density: state1.density,
                disparity: state1.disparity,
                saturation: state1.saturation,
                hideBlack: state1.hideBlack,
                randomness: state1.randomness,
                shape: state1.shape
              };
              reloadScheduled = false;
            });
          }
        }
        // FIX: Forcer retour exact au dernier √âtat quand zoomLevel proche de 1
        else if (zoomLevel > 0.999) {
          const lastState = uxStates[uxStates.length - 1];
          particleParams.size = lastState.size;
          particleParams.density = lastState.density;
          particleParams.disparity = lastState.disparity;
          particleParams.movement = lastState.movement;
          particleParams.randomness = lastState.randomness;
          particleParams.saturation = lastState.saturation;
          particleParams.hideBlack = lastState.hideBlack;
          particleParams.shape = lastState.shape;
          particleParams.movementMode = lastState.movementMode;
        }
        // Interpolation normale avec zoomLevel LISS√â (pas targetZoomLevel!)
        else {
          const globalProgress = zoomLevel; // UTILISE zoomLevel liss√©!
          const stateCount = uxStates.length;
          const scaledProgress = globalProgress * (stateCount - 1);
          const stateIndexFloat = Math.max(0, Math.min(scaledProgress, stateCount - 1));
          const fromStateIndex = Math.floor(stateIndexFloat);
          const toStateIndex = Math.min(fromStateIndex + 1, stateCount - 1);
          const localProgress = stateIndexFloat - fromStateIndex;

          const easedProgress = applyCurve(localProgress);

          const fromState = uxStates[fromStateIndex];
          const toState = uxStates[toStateIndex];

          // Interpoler tous les param√®tres de fa√ßon fluide
          particleParams.size = fromState.size + (toState.size - fromState.size) * easedProgress;
          particleParams.density = fromState.density + (toState.density - fromState.density) * easedProgress;
          particleParams.disparity = fromState.disparity + (toState.disparity - fromState.disparity) * easedProgress;
          particleParams.movement = fromState.movement + (toState.movement - fromState.movement) * easedProgress;
          particleParams.randomness = fromState.randomness + (toState.randomness - fromState.randomness) * easedProgress;
          particleParams.saturation = fromState.saturation + (toState.saturation - fromState.saturation) * easedProgress;
          particleParams.hideBlack = fromState.hideBlack + (toState.hideBlack - fromState.hideBlack) * easedProgress;

          if (easedProgress < 0.5) {
            particleParams.shape = fromState.shape;
            particleParams.movementMode = fromState.movementMode;
          } else {
            particleParams.shape = toState.shape;
            particleParams.movementMode = toState.movementMode;
          }
        }

        // Mise √† jour l√©g√®re du material size
        if (particles) {
          particles.material.size = particleParams.size;
        }

        // Note: Les throttled functions g√©reront les updates UI automatiquement

        // D√©tection de changement: ne recharger que si param√®tres lourds ont chang√©
        // DISPARITY RETIR√â: appliqu√© dynamiquement dans animate(), jamais de reload!
        let needsReload = particleParams.shape !== lastReloadParams.shape;

        if (!needsReload) {
          // √âviter Math.abs si diff√©rence est manifestement petite
          const densityDiff = particleParams.density - lastReloadParams.density;
          const saturationDiff = particleParams.saturation - lastReloadParams.saturation;
          const hideBlackDiff = particleParams.hideBlack - lastReloadParams.hideBlack;
          const randomnessDiff = particleParams.randomness - lastReloadParams.randomness;

          needsReload =
            (densityDiff > 0.01 || densityDiff < -0.01) ||
            (saturationDiff > 0.2 || saturationDiff < -0.2) ||
            (hideBlackDiff > 0.01 || hideBlackDiff < -0.01) ||
            (randomnessDiff > 0.01 || randomnessDiff < -0.01);
        }

        // Throttle du reload: utiliser requestAnimationFrame pour √©viter les reloads multiples
        if (needsReload && !reloadScheduled) {
          reloadScheduled = true;
          requestAnimationFrame(() => {
            loadImage(currentImageIndex);
            lastReloadParams = {
              density: particleParams.density,
              disparity: particleParams.disparity,
              saturation: particleParams.saturation,
              hideBlack: particleParams.hideBlack,
              randomness: particleParams.randomness,
              shape: particleParams.shape
            };
            reloadScheduled = false;
          });
        }
      }

      // Appliquer disparity dynamiquement SANS recr√©er la g√©om√©trie
      // OPTIMISATION PRO: Lerp smooth + update seulement si changement significatif (configurable)
      if (particles && particles.geometry.attributes.normalizedDepth) {
        const targetDisparity = particleParams.disparity;

        // Lerp smooth vers la valeur cible (transition ultra-fluide - configurable)
        if (Math.abs(targetDisparity - currentAppliedDisparity) > 0.001) {
          currentAppliedDisparity += (targetDisparity - currentAppliedDisparity) * scrollConfig.global.disparityLerp;

          // Seulement mettre √† jour GPU si changement visible (>0.001)
          if (lastAppliedDisparity === null || Math.abs(currentAppliedDisparity - lastAppliedDisparity) > 0.001) {
            const positions = particles.geometry.attributes.position.array;
            const initialPositions = particles.geometry.attributes.initialPosition.array;
            const normalizedDepths = particles.geometry.attributes.normalizedDepth.array;

            // OPTIMISATION: Loop unrolling pattern - traiter 4 particules √† la fois
            const disparity = currentAppliedDisparity;
            const len = normalizedDepths.length;
            let i = 0;

            // Loop principal: traiter par blocs de 4 (SIMD-like)
            for (; i < len - 3; i += 4) {
              const idx0 = i * 3;
              const idx1 = (i + 1) * 3;
              const idx2 = (i + 2) * 3;
              const idx3 = (i + 3) * 3;

              const depth0 = normalizedDepths[i] * disparity;
              const depth1 = normalizedDepths[i + 1] * disparity;
              const depth2 = normalizedDepths[i + 2] * disparity;
              const depth3 = normalizedDepths[i + 3] * disparity;

              initialPositions[idx0 + 2] = depth0;
              positions[idx0 + 2] = depth0;
              initialPositions[idx1 + 2] = depth1;
              positions[idx1 + 2] = depth1;
              initialPositions[idx2 + 2] = depth2;
              positions[idx2 + 2] = depth2;
              initialPositions[idx3 + 2] = depth3;
              positions[idx3 + 2] = depth3;
            }

            // G√©rer les particules restantes
            for (; i < len; i++) {
              const idx = i * 3;
              const depth = normalizedDepths[i] * disparity;
              initialPositions[idx + 2] = depth;
              positions[idx + 2] = depth;
            }

            // Marquer pour batch update au lieu d'update imm√©diat
            particles.geometry.attributes.initialPosition.needsUpdate = true;
            needsPositionUpdate = true;
            lastAppliedDisparity = currentAppliedDisparity;
            needsRender = true;
          }
        }
      }

      // Mouvement des particules avec 5 modes diff√©rents
      // OPTIMISATION PRO: Utilise function dispatch au lieu de branches dans loop chaud
      if (particles && particleParams.movement > 0) {
        particles.userData.time += 0.01;

        const positions = particles.geometry.attributes.position.array;
        const initialPositions = particles.geometry.attributes.initialPosition.array;
        const time = particles.userData.time;
        const movementDouble = particleParams.movement * 2;
        const mode = particleParams.movementMode;

        // R√©cup√©rer la fonction appropri√©e (1 lookup au lieu de branches r√©p√©t√©es)
        const movementFunc = movementFunctions[mode];

        // Loop optimis√© sans branches - CPU branch predictor est heureux
        if (movementFunc) {
          for (let i = 0; i < positions.length; i += 3) {
            movementFunc(positions, initialPositions, i, time, movementDouble);
          }
        }

        // Marquer pour batch update
        needsPositionUpdate = true;
        needsRender = true;
      }

      // OPTIMISATION PRO: Batch tous les updates GPU en un seul appel
      // Au lieu de multiples needsUpdate=true, on fait un seul appel √† la fin
      if (needsPositionUpdate && particles) {
        particles.geometry.attributes.position.needsUpdate = true;
        needsPositionUpdate = false;
      }

      // (Opt #5 - Early exit) Ne render que si n√©cessaire
      if (needsRender) {
        renderer.render(scene, camera);
      }
    }
    animate();

    // Gestion du redimensionnement
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Cache des boutons pour √©viter querySelectorAll r√©p√©t√©
    const cachedShapeButtons = document.querySelectorAll('.shape-btn');
    const cachedMovementButtons = document.querySelectorAll('.movement-mode-btn');

    // Cache des √©l√©ments UI pour updateUIValues (optimisation majeure)
    const uiElements = {
      sizeValue: document.getElementById('size-value'),
      densityValue: document.getElementById('density-value'),
      disparityValue: document.getElementById('disparity-value'),
      movementValue: document.getElementById('movement-value'),
      saturationValue: document.getElementById('saturation-value'),
      hideBlackValue: document.getElementById('hideBlack-value'),
      randomnessValue: document.getElementById('randomness-value'),
      sizeSlider: document.getElementById('size-slider'),
      densitySlider: document.getElementById('density-slider'),
      disparitySlider: document.getElementById('disparity-slider'),
      movementSlider: document.getElementById('movement-slider'),
      saturationSlider: document.getElementById('saturation-slider'),
      hideBlackSlider: document.getElementById('hideBlack-slider'),
      randomnessSlider: document.getElementById('randomness-slider')
    };

    // Throttle pour updateUIValues
    let uiUpdateScheduled = false;
    function throttledUpdateUIValues() {
      if (!uiUpdateScheduled) {
        uiUpdateScheduled = true;
        requestAnimationFrame(() => {
          updateUIValues();
          uiUpdateScheduled = false;
        });
      }
    }

    // Throttle pour les mises √† jour de boutons
    let buttonUpdateScheduled = false;
    let pendingButtonUpdates = { shape: null, movement: null };
    function throttledUpdateButtons(shape, movementMode) {
      pendingButtonUpdates.shape = shape;
      pendingButtonUpdates.movement = movementMode;

      if (!buttonUpdateScheduled) {
        buttonUpdateScheduled = true;
        requestAnimationFrame(() => {
          // Mettre √† jour les boutons de forme
          cachedShapeButtons.forEach(btn => {
            btn.classList.toggle('active', btn.dataset.shape === pendingButtonUpdates.shape);
          });
          // Mettre √† jour les boutons de mode de mouvement
          cachedMovementButtons.forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.mode) === pendingButtonUpdates.movement);
          });
          buttonUpdateScheduled = false;
        });
      }
    }

    /* ===============================================
       SCROLL CONFIG PANEL - Gestion
       =============================================== */

    // Configuration par d√©faut (valeurs optimis√©es selon recherche UX 2025)
    const scrollConfig = {
      trackpad: {
        sensitivity: 0.000267, // Divis√© par 1.5 pour scroll plus lent
        threshold: 70,         // Seuil de d√©tection trackpad
        frequency: 39          // Fr√©quence de d√©tection trackpad
      },
      wheel: {
        // PRO: Syst√®me d'accumulateur virtuel (technique Lenis/smooth-scroll)
        // Les clics discrets sont accumul√©s puis distribu√©s progressivement
        multiplier: 0.93,      // Divis√© par 3 pour scroll plus lent
        lerp: 0.22             // Distribution fluide sur plusieurs frames (300-500ms)
      },
      global: {
        zoomLerp: 0.18,        // R√©ponse lin√©aire et pr√©visible
        disparityLerp: 0.23
      }
    };

    // Elements UI
    const scrollConfigPanel = document.getElementById('scroll-config-panel');

    // Trackpad sliders
    const trackpadSensitivitySlider = document.getElementById('trackpad-sensitivity');
    const trackpadSensitivityVal = document.getElementById('trackpad-sensitivity-val');
    const trackpadThresholdSlider = document.getElementById('trackpad-threshold');
    const trackpadThresholdVal = document.getElementById('trackpad-threshold-val');
    const trackpadFrequencySlider = document.getElementById('trackpad-frequency');
    const trackpadFrequencyVal = document.getElementById('trackpad-frequency-val');

    // Wheel sliders (nouveau syst√®me PRO)
    const wheelMultiplierSlider = document.getElementById('wheel-multiplier');
    const wheelMultiplierVal = document.getElementById('wheel-multiplier-val');
    const wheelLerpSlider = document.getElementById('wheel-lerp');
    const wheelLerpVal = document.getElementById('wheel-lerp-val');

    // Global sliders
    const zoomLerpSlider = document.getElementById('zoom-lerp');
    const zoomLerpVal = document.getElementById('zoom-lerp-val');
    const disparityLerpSlider = document.getElementById('disparity-lerp');
    const disparityLerpVal = document.getElementById('disparity-lerp-val');

    // Info indicators
    const scrollModeIndicator = document.getElementById('scroll-mode-indicator');
    const scrollDeltaIndicator = document.getElementById('scroll-delta-indicator');
    const scrollFreqIndicator = document.getElementById('scroll-freq-indicator');

    // Buttons
    const scrollResetBtn = document.getElementById('scroll-reset-btn');
    const scrollCopyBtn = document.getElementById('scroll-copy-btn');

    // Update handlers
    trackpadSensitivitySlider.addEventListener('input', (e) => {
      scrollConfig.trackpad.sensitivity = parseFloat(e.target.value);
      trackpadSensitivityVal.textContent = scrollConfig.trackpad.sensitivity.toFixed(6);
    });

    trackpadThresholdSlider.addEventListener('input', (e) => {
      scrollConfig.trackpad.threshold = parseFloat(e.target.value);
      trackpadThresholdVal.textContent = scrollConfig.trackpad.threshold;
    });

    trackpadFrequencySlider.addEventListener('input', (e) => {
      scrollConfig.trackpad.frequency = parseFloat(e.target.value);
      trackpadFrequencyVal.textContent = scrollConfig.trackpad.frequency;
    });

    wheelMultiplierSlider.addEventListener('input', (e) => {
      scrollConfig.wheel.multiplier = parseFloat(e.target.value);
      wheelMultiplierVal.textContent = scrollConfig.wheel.multiplier.toFixed(2);
    });

    wheelLerpSlider.addEventListener('input', (e) => {
      scrollConfig.wheel.lerp = parseFloat(e.target.value);
      wheelLerpVal.textContent = scrollConfig.wheel.lerp.toFixed(2);
    });

    zoomLerpSlider.addEventListener('input', (e) => {
      scrollConfig.global.zoomLerp = parseFloat(e.target.value);
      zoomLerpVal.textContent = scrollConfig.global.zoomLerp.toFixed(2);
    });

    disparityLerpSlider.addEventListener('input', (e) => {
      scrollConfig.global.disparityLerp = parseFloat(e.target.value);
      disparityLerpVal.textContent = scrollConfig.global.disparityLerp.toFixed(2);
    });

    // Reset button
    scrollResetBtn.addEventListener('click', () => {
      // Reset to PRO defaults (vitesses r√©duites: trackpad /1.5, molette /3)
      scrollConfig.trackpad = { sensitivity: 0.000267, threshold: 70, frequency: 39 };
      scrollConfig.wheel = { multiplier: 0.93, lerp: 0.22 };
      scrollConfig.global = { zoomLerp: 0.18, disparityLerp: 0.23 };

      // Update sliders
      trackpadSensitivitySlider.value = 0.000267;
      trackpadSensitivityVal.textContent = '0.000267';
      trackpadThresholdSlider.value = 70;
      trackpadThresholdVal.textContent = '70';
      trackpadFrequencySlider.value = 39;
      trackpadFrequencyVal.textContent = '39';

      wheelMultiplierSlider.value = 0.93;
      wheelMultiplierVal.textContent = '0.93';
      wheelLerpSlider.value = 0.22;
      wheelLerpVal.textContent = '0.22';

      zoomLerpSlider.value = 0.18;
      zoomLerpVal.textContent = '0.18';
      disparityLerpSlider.value = 0.23;
      disparityLerpVal.textContent = '0.23';

      console.log('‚úÖ Scroll config reset to PRO defaults (accumulateur virtuel Lenis)');
    });

    // Copy config button
    scrollCopyBtn.addEventListener('click', async () => {
      const configJSON = JSON.stringify(scrollConfig, null, 2);
      try {
        await navigator.clipboard.writeText(configJSON);
        scrollCopyBtn.textContent = '‚úÖ Copied!';
        console.log('üìã Config copied to clipboard:');
        console.log(configJSON);
        setTimeout(() => {
          scrollCopyBtn.textContent = 'üìã Copy Config to Clipboard';
        }, 2000);
      } catch (err) {
        console.error('Failed to copy:', err);
        console.log('üìã Copy this config manually:');
        console.log(configJSON);
      }
    });

    window.addEventListener('wheel', (event) => {
      // Bloquer scroll de page - le scroll agit uniquement sur le zoom
      event.preventDefault();

      const now = performance.now();
      const deltaTime = now - lastScrollTime;
      lastScrollTime = now;

      // D√âTECTION INTELLIGENTE: trackpad vs molette (utilise scrollConfig)
      const absDelta = Math.abs(event.deltaY);
      const isTrackpad = absDelta < scrollConfig.trackpad.threshold || deltaTime < scrollConfig.trackpad.frequency;

      // Mise √† jour des indicateurs (si panel visible)
      if (scrollConfigPanel.classList.contains('visible')) {
        scrollModeIndicator.textContent = isTrackpad ? 'üì± Trackpad' : 'üñ±Ô∏è Mouse Wheel';
        scrollDeltaIndicator.textContent = absDelta.toFixed(1);
        scrollFreqIndicator.textContent = deltaTime.toFixed(0) + 'ms';
      }

      let scrollDelta;
      if (isTrackpad) {
        // TRACKPAD: usage direct avec sensibilit√© configurable
        scrollDelta = event.deltaY * scrollConfig.trackpad.sensitivity;
        wheelScrollAccumulator = 0; // Reset accumulator

        // CYCLE DE SCROLL: Inverser selon la phase
        if (scrollPhase === 'zoomIn') {
          // Scroll vers le bas = zoom IN (positif)
          targetZoomLevel += scrollDelta;
        } else if (scrollPhase === 'zoomOut') {
          // Scroll vers le bas = zoom OUT (n√©gatif) - INVERSION
          targetZoomLevel -= scrollDelta;
        }
      } else {
        // PRO WHEEL SMOOTHING: Accumulateur virtuel (technique Lenis/smooth-scroll 2025)
        // L'inversion selon phase sera appliqu√©e dans animate()
        wheelScrollAccumulator += event.deltaY * scrollConfig.trackpad.sensitivity * scrollConfig.wheel.multiplier;
      }

      // Limiter entre 0 et MAX_ZOOM_LEVEL
      targetZoomLevel = Math.max(0, Math.min(MAX_ZOOM_LEVEL, targetZoomLevel));

      // FIX MOLETTE: Ne plus calculer les param√®tres ici avec targetZoomLevel (qui saute)
      // Les param√®tres sont maintenant calcul√©s dans animate() avec zoomLevel liss√©
      // Cela √©limine les "t√©l√©portations" des particules avec la molette!
    }, { passive: false });

    /* ===============================================
       ARRI√àRE-PLANS JONAS
       =============================================== */

    // Arri√®re-plans Jonas
    let jonasBackgroundVisible = false;
    const jonasBackground = document.getElementById('jonas-background');
    const jonasBgColor = document.getElementById('jonas-bg-color');

    let jonasBackgroundNegatifVisible = false;
    const jonasBackgroundNegatif = document.getElementById('jonas-background-negatif');
    const jonasBgColorNegatif = document.getElementById('jonas-bg-color-negatif');

    // Activer le fond noir + typo blanche au chargement (comme touche N)
    window.addEventListener('load', () => {
      jonasBgColorNegatif.classList.add('visible');
      jonasBackgroundNegatif.classList.add('visible');
      jonasBackgroundNegatifVisible = true;
    });

    window.addEventListener('keydown', (event) => {
      // Fl√®che gauche - Image pr√©c√©dente
      if (event.key === 'ArrowLeft') {
        currentImageIndex = currentImageIndex === 1 ? maxImageIndex : currentImageIndex - 1;
        loadImage(currentImageIndex);
      }

      // Fl√®che droite - Image suivante
      if (event.key === 'ArrowRight') {
        currentImageIndex = currentImageIndex === maxImageIndex ? 1 : currentImageIndex + 1;
        loadImage(currentImageIndex);
      }

      // Touche I - Ouvrir/fermer l'interface de param√©trage
      if (event.key === 'i' || event.key === 'I') {
        settingsPanel.classList.toggle('visible');
      }

      // Touche J - Fond blanc + Typo noire
      if (event.key === 'j' || event.key === 'J') {
        jonasBackgroundVisible = !jonasBackgroundVisible;

        if (jonasBackgroundVisible) {
          // Afficher fond blanc + typo noire
          jonasBgColor.classList.add('visible');
          jonasBackground.classList.add('visible');
          // Masquer le n√©gatif si visible
          jonasBgColorNegatif.classList.remove('visible');
          jonasBackgroundNegatif.classList.remove('visible');
          jonasBackgroundNegatifVisible = false;
        } else {
          // Tout masquer
          jonasBgColor.classList.remove('visible');
          jonasBackground.classList.remove('visible');
        }
      }

      // Touche N - Fond noir + Typo blanche
      if (event.key === 'n' || event.key === 'N') {
        jonasBackgroundNegatifVisible = !jonasBackgroundNegatifVisible;

        if (jonasBackgroundNegatifVisible) {
          // Afficher fond noir + typo blanche
          jonasBgColorNegatif.classList.add('visible');
          jonasBackgroundNegatif.classList.add('visible');
          // Masquer le normal si visible
          jonasBgColor.classList.remove('visible');
          jonasBackground.classList.remove('visible');
          jonasBackgroundVisible = false;
        } else {
          // Tout masquer
          jonasBgColorNegatif.classList.remove('visible');
          jonasBackgroundNegatif.classList.remove('visible');
        }
      }

      // Touche M - Ouvrir l'interface √âtats de Lecture
      if (event.key === 'm' || event.key === 'M') {
        const uxStatesPanel = document.getElementById('ux-states-panel');
        uxStatesPanel.classList.toggle('visible');
        if (uxStatesPanel.classList.contains('visible')) {
          renderUXStates();
        }
      }

      // Touche C - Ouvrir l'interface de configuration du scroll
      if (event.key === 'c' || event.key === 'C') {
        const scrollConfigPanel = document.getElementById('scroll-config-panel');
        scrollConfigPanel.classList.toggle('visible');
      }

      // Fl√®ches haut/bas - Naviguer entre les √©tats (quand interface M est ouverte)
      if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
        const uxStatesPanel = document.getElementById('ux-states-panel');
        if (uxStatesPanel.classList.contains('visible') && uxStates.length > 0) {
          event.preventDefault();

          if (event.key === 'ArrowUp') {
            // √âtat pr√©c√©dent
            if (currentStateIndex === -1) {
              currentStateIndex = uxStates.length - 1;
            } else {
              currentStateIndex = currentStateIndex === 0 ? uxStates.length - 1 : currentStateIndex - 1;
            }
          } else {
            // √âtat suivant
            if (currentStateIndex === -1) {
              currentStateIndex = 0;
            } else {
              currentStateIndex = currentStateIndex === uxStates.length - 1 ? 0 : currentStateIndex + 1;
            }
          }

          // Charger les param√®tres de l'√©tat s√©lectionn√©
          loadState(currentStateIndex);

          // Sauter directement au niveau de zoom de l'√©tat (saccade)
          if (uxJourneyMode && uxStates.length > 1) {
            targetZoomLevel = currentStateIndex / (uxStates.length - 1);
          }

          // Mettre √† jour l'affichage
          renderUXStates();
          // Activer le bouton APPLY
          uxApplyBtn.disabled = false;
        }
      }
    });

    /* FIN SECTION ARRI√àRE-PLANS JONAS */

    /* ===============================================
       GESTION INTERFACE √âTATS DE LECTURE
       =============================================== */

    const uxStatesPanel = document.getElementById('ux-states-panel');
    const uxStatesList = document.getElementById('ux-states-list');
    const uxAddStateBtn = document.getElementById('ux-add-state');
    const uxApplyBtn = document.getElementById('ux-apply-state');
    const uxCurveSelect = document.getElementById('ux-curve-type');
    const uxToggleBtn = document.getElementById('ux-toggle');

    // Fonction pour sauvegarder les param√®tres actuels dans l'√©tat s√©lectionn√©
    function saveCurrentState() {
      if (currentStateIndex >= 0 && currentStateIndex < uxStates.length) {
        uxStates[currentStateIndex].size = particleParams.size;
        uxStates[currentStateIndex].density = particleParams.density;
        uxStates[currentStateIndex].disparity = particleParams.disparity;
        uxStates[currentStateIndex].movement = particleParams.movement;
        uxStates[currentStateIndex].randomness = particleParams.randomness;
        uxStates[currentStateIndex].saturation = particleParams.saturation;
        uxStates[currentStateIndex].hideBlack = particleParams.hideBlack;
        uxStates[currentStateIndex].shape = particleParams.shape;
        uxStates[currentStateIndex].movementMode = particleParams.movementMode;
      }
    }

    // Fonction pour charger un √©tat
    function loadState(index) {
      if (index >= 0 && index < uxStates.length) {
        particleParams.size = uxStates[index].size;
        particleParams.density = uxStates[index].density;
        particleParams.disparity = uxStates[index].disparity;
        particleParams.movement = uxStates[index].movement;
        particleParams.randomness = uxStates[index].randomness;
        particleParams.saturation = uxStates[index].saturation;
        particleParams.hideBlack = uxStates[index].hideBlack;
        particleParams.shape = uxStates[index].shape;
        particleParams.movementMode = uxStates[index].movementMode;

        // Mettre √† jour les boutons de forme
        document.querySelectorAll('.shape-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.shape === particleParams.shape);
        });

        // Mettre √† jour les boutons de mode de mouvement
        document.querySelectorAll('.movement-mode-btn').forEach(btn => {
          btn.classList.toggle('active', parseInt(btn.dataset.mode) === particleParams.movementMode);
        });

        updateUIValues();
        loadImage(currentImageIndex);
      }
    }

    // Fonction pour rendre les boutons d'√©tats
    function renderUXStates() {
      uxStatesList.innerHTML = '';
      uxStates.forEach((state, index) => {
        const btn = document.createElement('button');
        btn.className = 'ux-state-btn';
        if (index === currentStateIndex) {
          btn.classList.add('active');
        }
        btn.textContent = state.name;
        btn.addEventListener('click', () => {
          // S√©lectionner/d√©s√©lectionner l'√©tat
          if (currentStateIndex === index) {
            // D√©s√©lectionner si on clique sur le m√™me
            currentStateIndex = -1;
          } else {
            // S√©lectionner l'√©tat
            currentStateIndex = index;
          }
          // Mettre √† jour l'affichage
          renderUXStates();
          // Activer/d√©sactiver le bouton APPLY
          uxApplyBtn.disabled = currentStateIndex === -1;
        });
        uxStatesList.appendChild(btn);
      });
    }

    // Bouton ajouter un √©tat
    uxAddStateBtn.addEventListener('click', () => {
      // Cr√©er un nouvel √©tat avec les param√®tres par d√©faut
      const newState = {
        name: `√âtat ${uxStates.length + 1}`,
        size: 0.02,
        density: 0.4,
        disparity: 0.0,
        movement: 0.0,
        randomness: 0.0,
        saturation: 1.0,
        hideBlack: 0.0,
        shape: 'circle',
        movementMode: 1
      };

      uxStates.push(newState);
      // Ne pas s√©lectionner automatiquement le nouvel √©tat
      renderUXStates();
    });

    // Bouton appliquer les param√®tres
    uxApplyBtn.addEventListener('click', () => {
      if (currentStateIndex >= 0 && currentStateIndex < uxStates.length) {
        // Sauvegarder les param√®tres actuels dans l'√©tat s√©lectionn√©
        saveCurrentState();
        console.log(`√âtat ${currentStateIndex + 1} mis √† jour avec les param√®tres actuels`);
      }
    });

    // S√©lecteur de courbe
    uxCurveSelect.addEventListener('change', (e) => {
      selectedCurveType = e.target.value;
    });

    // Bouton activer/d√©sactiver le parcours UX
    uxToggleBtn.addEventListener('click', () => {
      uxJourneyMode = !uxJourneyMode;

      if (uxJourneyMode) {
        // Activer le mode
        uxToggleBtn.textContent = 'D√©sactiver';
        uxToggleBtn.classList.add('active');
        targetZoomLevel = 0;
        // Charger le premier √©tat
        loadState(0);
        console.log('Mode parcours UX activ√©');
      } else {
        // D√©sactiver le mode
        uxToggleBtn.textContent = 'Actif';
        uxToggleBtn.classList.remove('active');
        console.log('Mode parcours UX d√©sactiv√©');
      }
    });

    // Restaurer l'√©tat de l'interface au chargement
    if (uxJourneyMode) {
      uxToggleBtn.textContent = 'D√©sactiver';
      uxToggleBtn.classList.add('active');
    } else {
      uxToggleBtn.textContent = 'Actif';
      uxToggleBtn.classList.remove('active');
    }
    uxCurveSelect.value = selectedCurveType;

    // Charger l'√âtat 1 au d√©marrage de la page
    if (uxStates.length > 0) {
      loadState(0); // Charger √âtat 1 (index 0)
    }

    /* FIN GESTION INTERFACE √âTATS DE LECTURE */

    /* ===============================================
       INTERFACE DE PARAM√âTRAGE
       =============================================== */

    const settingsPanel = document.getElementById('settings-panel');

    // Valeurs par d√©faut (√©tat 01)
    const defaultParams = {
      size: 0.02,
      density: 0.4,      // Bloqu√© √† 0.4
      disparity: 0.0,
      movement: 0.0,
      saturation: 1.0,
      hideBlack: 0.0,
      randomness: 0.0,
      shape: 'circle',
      movementMode: 1
    };

    // Fonction pour mettre √† jour l'affichage de l'UI (utilise cache)
    function updateUIValues() {
      uiElements.sizeValue.textContent = particleParams.size.toFixed(3);
      uiElements.densityValue.textContent = particleParams.density.toFixed(1);
      uiElements.disparityValue.textContent = particleParams.disparity.toFixed(1);
      uiElements.movementValue.textContent = particleParams.movement.toFixed(3);
      uiElements.saturationValue.textContent = particleParams.saturation.toFixed(1);
      uiElements.hideBlackValue.textContent = particleParams.hideBlack.toFixed(2);
      uiElements.randomnessValue.textContent = particleParams.randomness.toFixed(2);

      // Mettre √† jour les sliders aussi
      uiElements.sizeSlider.value = particleParams.size;
      uiElements.densitySlider.value = particleParams.density;
      uiElements.disparitySlider.value = particleParams.disparity;
      uiElements.movementSlider.value = particleParams.movement;
      uiElements.saturationSlider.value = particleParams.saturation;
      uiElements.hideBlackSlider.value = particleParams.hideBlack;
      uiElements.randomnessSlider.value = particleParams.randomness;
    }

    // Helper pour mettre √† jour un param√®tre
    function updateParam(param, value, updateSlider = true) {
      const slider = document.getElementById(`${param}-slider`);
      const valueDisplay = document.getElementById(`${param}-value`);

      const min = parseFloat(slider.min);
      const max = parseFloat(slider.max);
      value = Math.max(min, Math.min(max, value));

      if (param === 'size') {
        particleParams.size = value;
        valueDisplay.textContent = value.toFixed(3);
        if (particles) particles.material.size = value;
      } else if (param === 'density') {
        particleParams.density = value;
        valueDisplay.textContent = value.toFixed(1);
        loadImage(currentImageIndex);
      } else if (param === 'disparity') {
        particleParams.disparity = value;
        valueDisplay.textContent = value.toFixed(1);
        loadImage(currentImageIndex);
      } else if (param === 'movement') {
        particleParams.movement = value;
        valueDisplay.textContent = value.toFixed(3);
      } else if (param === 'saturation') {
        particleParams.saturation = value;
        valueDisplay.textContent = value.toFixed(1);
        loadImage(currentImageIndex);
      } else if (param === 'hideBlack') {
        particleParams.hideBlack = value;
        valueDisplay.textContent = value.toFixed(2);
        loadImage(currentImageIndex);
      } else if (param === 'randomness') {
        particleParams.randomness = value;
        valueDisplay.textContent = value.toFixed(2);
        loadImage(currentImageIndex);
      }

      if (updateSlider) {
        slider.value = value;
      }
    }

    // Sliders
    ['size', 'density', 'disparity', 'movement', 'saturation', 'hideBlack', 'randomness'].forEach(param => {
      const slider = document.getElementById(`${param}-slider`);
      slider.addEventListener('input', (e) => {
        updateParam(param, parseFloat(e.target.value), false);
      });
    });

    // Boutons +/-
    document.querySelectorAll('.param-btn').forEach(btn => {
      const param = btn.dataset.param;

      btn.addEventListener('click', () => {
        const action = btn.dataset.action;
        const slider = document.getElementById(`${param}-slider`);
        const step = parseFloat(slider.step);
        const currentValue = parseFloat(slider.value);

        const newValue = action === 'increase' ? currentValue + step : currentValue - step;
        updateParam(param, newValue);
      });
    });

    // Boutons de forme (rond/carr√©)
    document.querySelectorAll('.shape-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        // Retirer active de tous les boutons
        document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
        // Ajouter active au bouton cliqu√©
        btn.classList.add('active');
        // Mettre √† jour le param√®tre
        particleParams.shape = btn.dataset.shape;
        // Recharger l'image avec la nouvelle forme
        loadImage(currentImageIndex);
      });
    });

    // Boutons de mode de mouvement
    document.querySelectorAll('.movement-mode-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        // Retirer active de tous les boutons
        document.querySelectorAll('.movement-mode-btn').forEach(b => b.classList.remove('active'));
        // Ajouter active au bouton cliqu√©
        btn.classList.add('active');
        // Mettre √† jour le param√®tre
        particleParams.movementMode = parseInt(btn.dataset.mode);
      });
    });

    // Apply button
    document.getElementById('apply-btn').addEventListener('click', () => {
      // Recharger avec tous les param√®tres
      loadImage(currentImageIndex);
    });

    // Reset to Defaults
    document.getElementById('reset-defaults-btn').addEventListener('click', () => {
      Object.keys(defaultParams).forEach(param => {
        if (param === 'shape') {
          particleParams.shape = defaultParams[param];
          document.querySelectorAll('.shape-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.shape === defaultParams[param]);
          });
        } else if (param === 'movementMode') {
          particleParams.movementMode = defaultParams[param];
          document.querySelectorAll('.movement-mode-btn').forEach(btn => {
            btn.classList.toggle('active', parseInt(btn.dataset.mode) === defaultParams[param]);
          });
        } else {
          updateParam(param, defaultParams[param]);
        }
      });
      loadImage(currentImageIndex);
    });

    // Reset Camera
    document.getElementById('reset-camera-btn').addEventListener('click', () => {
      targetZoomLevel = 0.5;
      sceneGroup.rotation.set(0, 0, 0);
      // La position de la cam√©ra sera automatiquement interpol√©e par animate()
    });

    /* FIN INTERFACE DE PARAM√âTRAGE */

    /* ===============================================
       SECTION D√âSACTIV√âE - INTERACTIONS UTILISATEUR
       ===============================================
       Cette section contient tout le code d'interaction :
       - Navigation avec fl√®ches
       - Zoom avec molette
       - Drag and drop (clic maintenu)
       - Mode sc√®ne/cam√©ra
       - Bouton reset
       - Page d'accueil/intro
       - Curseur personnalis√©
       - √âv√©nements tactiles
    */

    /*
    // Variables d'interaction
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let viewMode = 'scene';

    // Navigation avec les fl√®ches
    document.getElementById('arrow-left').addEventListener('click', () => {
      currentImageIndex = currentImageIndex === 0 ? maxImageIndex : currentImageIndex - 1;
      loadImage(currentImageIndex);
    });

    document.getElementById('arrow-right').addEventListener('click', () => {
      currentImageIndex = currentImageIndex === maxImageIndex ? 0 : currentImageIndex + 1;
      loadImage(currentImageIndex);
    });

    // Zoom avec molette
    window.addEventListener('wheel', (event) => {
      event.preventDefault();
      // Code de zoom...
    }, { passive: false });

    // Drag and drop
    window.addEventListener('mousedown', (event) => {
      isDragging = true;
      previousMousePosition = { x: event.clientX, y: event.clientY };
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
    });

    window.addEventListener('mousemove', (event) => {
      if (isDragging) {
        const deltaMove = {
          x: event.clientX - previousMousePosition.x,
          y: event.clientY - previousMousePosition.y,
        };

        if (viewMode === 'scene') {
          sceneGroup.rotation.y += deltaMove.x * 0.003;
          sceneGroup.rotation.x += deltaMove.y * 0.003;
        }

        previousMousePosition = { x: event.clientX, y: event.clientY };
      }
    });

    // Bouton reset
    document.getElementById('resetCamera').addEventListener('click', () => {
      // Code reset...
    });

    // Modes sc√®ne/cam√©ra
    document.getElementById('mode-scene').addEventListener('click', () => {
      viewMode = 'scene';
    });

    document.getElementById('mode-camera').addEventListener('click', () => {
      viewMode = 'camera';
    });

    // Page d'accueil
    document.getElementById('startButton').addEventListener('click', () => {
      // Code intro...
    });

    // Curseur personnalis√©
    const customCursor = document.getElementById('custom-cursor');
    document.addEventListener('mousemove', (e) => {
      customCursor.style.left = e.clientX + 'px';
      customCursor.style.top = e.clientY + 'px';
    });
    */

    /* FIN SECTION D√âSACTIV√âE - INTERACTIONS */

  </script>
</body>
</html>
